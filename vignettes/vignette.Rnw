\documentclass{article}

\begin{document}

<<include=FALSE>>=
library(knitr)
opts_chunk$set(
concordance=TRUE
)
@

<<setup, include=FALSE, cache=FALSE, tidy=TRUE>>=
options(tidy=TRUE, width.cutoff=50)
@


<<>>=
library(PLIER)
@
\section{Some Notes}
PLIER runs reasonably fast but to get the best performance we recommend that you use linear algebra libraries optimized for your system. For Ubuntu and Windows you can follow instructions at http://brettklamer.com/diversions/statistical/faster-blas-in-r/.
\section{Vaccination Dataset}
Load data
<<echo=TRUE>>=
data(bloodCellMarkersIRISDMAP)
data(svmMarkers)
data(canonicalPathways)
data(vacData)
@
Construct a joint pathway matrix by merging canonicalPathways, bloodCellMarkersIRISDMAP and svmMarkers and select genes appearing in both gene expression profile and the joint pathway matrix.
<<echo=TRUE>>=
allPaths=combinePaths(bloodCellMarkersIRISDMAP, svmMarkers, canonicalPathways)
cm.genes=commonRows(allPaths, vacData)
@
Normalize the data and approximate the number of latent variables in the data by num.pc(). The result is 26. Note: num.pc() is quite conservative and we recommend to set this value about 30 to 50\% higher. We set  k=34 and all other parameters to be default. We set the seed to get reprducible results for held-out pathway genes.
<<echo=TRUE>>=
vacDataN=rowNorm(vacData)
num.pc(vacDataN)
#plierResult=PLIER(vacDataN[cm.genes,], allPaths[cm.genes,],k=34, trace=T, seed = 123)
@
In the interest of speed we provide a pre-computed version though for this example it will only take less than a minute.
<<echo=TRUE>>=
data(plierResult)
@

Visualize the U matrix with default cutoffs
<<echo=TRUE>>=
plotU(plierResult, auc.cutoff = 0.70, fdr.cutoff = 0.05, top = 3)
@
Visualize the U matrix with more permissive cutoffs
<<echo=TRUE>>=
plotU(plierResult, auc.cutoff = 0.6, fdr.cutoff = 0.2, top = 3)
@

We can correlate the decomposition result with SPVs from CellCODE like this.
<<echo=TRUE>>=
data(SPVs)
plotMat(cor(t(plierResult$B), SPVs), scale = F)
@
 We have nice one-to-one  correspondence, though the "DendriticCell"ignature from CellCODE is more closely related to the Type-I interferon transcriptional response so it is probably not cell-type induced variation.

We can see that LVs  1, 8, 9, 11, 16, 21, 33  roughly correspond to major cell-types and we can use this to derive data-driven cell-type markers, which can be plugged into the CellCODE pipeline. 
<<echo=TRUE>>=
markers=plierResToMarkers(plierResult, allPaths, index = c( 1, 8, 9, 11, 16, 21, 33))
colnames(markers)
@

We can also visualize the top genes and their pathway associations. Note: only LVs with pathway association are plotted.
<<echo=TRUE>>=
indexToPlot=which(apply(plierResult$Uauc,2,max)>0.75)
plotTopZ(plierResult, vacDataN, allPaths, top = 5, index =  indexToPlot)
@

Let's plot some of the less reliable LVs
<<echo=TRUE, tidy=T>>=
plotTopZ(plierResult, vacDataN, allPaths, top = 15, index =  c(3,32))
@
We can see that in this case not all genes have the pathway(s) annotation.


Since each LV may (and often is) be associated with more than one pathway it can be useful to visualize all the different annotations. We can also plot more genes since for some small ro weakly predicted pathways they may be quite far from the top.
<<echo=TRUE, fig.height=12, tidy=T>>=
plotTopZallPath(plierResult, vacDataN, allPaths, top = 50, index =  c(32))
@


\end{document}
